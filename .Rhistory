}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
# diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
if(stp)
break
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
logisticReg <- function(X,Y,lr=1,threshold=0.001){
params <- rep(0,ncol(x_train)+1)
prev_loss <- 0.0
diff <- Inf
while(TRUE){
curr_loss <- 0.0
gradient <- rep(0,length(params))
stp <- FALSE
for(row in 1:nrow(X)){
diff <- 0
x<-as.numeric(c(list(1),X[row,]))
pred <- as.double(1/as.double(1+exp(-(x%*%params))))
loss <- Y[row] - pred
curr_loss <- curr_loss + (loss^2)
for(p in 1:length(params)){
params[p] <- params[p] + lr*x[p]*loss
diff <- diff + (lr*x[p]*loss)^2
}
if(sqrt(diff)<threshold){
stp = TRUE
break
}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
# diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
if(stp)
break
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
logisticReg <- function(X,Y,lr=1,threshold=0.00001){
params <- rep(0,ncol(x_train)+1)
prev_loss <- 0.0
diff <- Inf
while(TRUE){
curr_loss <- 0.0
gradient <- rep(0,length(params))
stp <- FALSE
for(row in 1:nrow(X)){
diff <- 0
x<-as.numeric(c(list(1),X[row,]))
pred <- as.double(1/as.double(1+exp(-(x%*%params))))
loss <- Y[row] - pred
curr_loss <- curr_loss + (loss^2)
for(p in 1:length(params)){
params[p] <- params[p] + lr*x[p]*loss
diff <- diff + (lr*x[p]*loss)^2
}
if(sqrt(diff)<threshold){
stp = TRUE
break
}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
# diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
if(stp)
break
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
sqrt(sum((y_train-predict(model,x_train,type='response'))^2))
sqrt(sum((y_train - apply(x_train,1,getPred))^2))
logisticReg <- function(X,Y,lr=1,threshold=0.1){
params <- rep(0,ncol(x_train)+1)
prev_loss <- 0.0
diff <- Inf
while(diff>threshold){
curr_loss <- 0.0
gradient <- rep(0,length(params))
diff <- 0
for(row in 1:nrow(X)){
x<-as.numeric(c(list(1),X[row,]))
pred <- as.double(1/as.double(1+exp(-(x%*%params))))
loss <- Y[row] - pred
curr_loss <- curr_loss + (loss^2)
for(p in 1:length(params)){
params[p] <- params[p] + lr*x[p]*loss
}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
data <- read.csv('salesmlr.csv')
x1 <- data$budgetNews
x2 <- data$budgetTv
y <- data$totalUnits
productSum <- function(x1,x2){
#find summation of (x1-x1_)(x2-x2_)
return(sum(x1*x2)-(sum(x1)*sum(x2))/length(x1))
}
findBk <- function(xk,xn,y){
num <- productSum(xn,xn)*productSum(xk,y) - productSum(xk,xn)*productSum(xn,y)
den <- productSum(xk,xk)*productSum(xn,xn) - productSum(xk,xn)^2
return(num/den)
}
b_1 <- findBk(x1,x2,y)
b_2 <- findBk(x2,x1,y)
b_0 <- y_ - b_1*x1_ - b_2*x2_
getPred<-function(x){
return (b_0+(b_1*x[1])+(b_2*x[2]))
}
x_test = data.frame("budgetNews"=c(150,300,450,600,750),"budgetTv"=c(3000,4000,5000,6000,7000))
predicted<-apply(x_test,1,getPred)
predicted
b_0 <- y_ - b_1*x1_ - b_2*x2_
x1_ <- sum(x1)/length(x1)
x2_ <- sum(x2)/length(x2)
y_ <- sum(y)/length(y)
b_1 <- findBk(x1,x2,y)
b_2 <- findBk(x2,x1,y)
b_0 <- y_ - b_1*x1_ - b_2*x2_
getPred<-function(x){
return (b_0+(b_1*x[1])+(b_2*x[2]))
}
x_test = data.frame("budgetNews"=c(150,300,450,600,750),"budgetTv"=c(3000,4000,5000,6000,7000))
predicted<-apply(x_test,1,getPred)
predicted
#using library function for mlr
model <- lm(totalUnits ~ budgetNews+budgetTv,data=data)
summary(model)
predictions_lib<-predict(model,x_test)
predictions_lib
#Comparison Table
library(grid)
library(gridExtra)
result = data.frame("budgetTv"=c(3000,4000,5000,6000,7000),"budgetNews"=c(150,300,450,600,750),"predictions"=predicted,"predictions_lib"=predictions_lib)
grid.table(result)
coeff_table <- data.frame("Non Predefined Function"=c(b_0,b_1,b_2),"Predefined Function"=summary(model)$coefficients[1:3])
rownames(coeff_table) <- c("Intercept", "budgetTv", "budgetNews")
grid.arrange(tableGrob(coeff_table),tableGrob(result))
data <- read.csv('salesmlr.csv')
x1 <- data$budgetNews
x2 <- data$budgetTv
y <- data$totalUnits
x1_ <- sum(x1)/length(x1)
x2_ <- sum(x2)/length(x2)
y_ <- sum(y)/length(y)
productSum <- function(x1,x2){
#find summation of (x1-x1_)(x2-x2_)
return(sum(x1*x2)-(sum(x1)*sum(x2))/length(x1))
}
findBk <- function(xk,xn,y){
num <- productSum(xn,xn)*productSum(xk,y) - productSum(xk,xn)*productSum(xn,y)
den <- productSum(xk,xk)*productSum(xn,xn) - productSum(xk,xn)^2
return(num/den)
}
b_1 <- findBk(x1,x2,y)
b_2 <- findBk(x2,x1,y)
b_0 <- y_ - b_1*x1_ - b_2*x2_
getPred<-function(x){
return (b_0+(b_1*x[1])+(b_2*x[2]))
}
x_test = data.frame("budgetNews"=c(150,300,450,600,750),"budgetTv"=c(3000,4000,5000,6000,7000))
predicted<-apply(x_test,1,getPred)
predicted
#using library function for mlr
model <- lm(totalUnits ~ budgetNews+budgetTv,data=data)
summary(model)
predictions_lib<-predict(model,x_test)
predictions_lib
#Comparison Table
library(grid)
library(gridExtra)
result = data.frame("budgetTv"=c(3000,4000,5000,6000,7000),"budgetNews"=c(150,300,450,600,750),"predictions"=predicted,"predictions_lib"=predictions_lib)
grid.table(result)
coeff_table <- data.frame("Non Predefined Function"=c(b_0,b_1,b_2),"Predefined Function"=summary(model)$coefficients[1:3])
rownames(coeff_table) <- c("Intercept", "budgetTv", "budgetNews")
grid.arrange(tableGrob(coeff_table),tableGrob(result))
data <- read.csv('salesmlr.csv')
x1 <- data$budgetNews
x2 <- data$budgetTv
y <- data$totalUnits
x1_ <- sum(x1)/length(x1)
x2_ <- sum(x2)/length(x2)
y_ <- sum(y)/length(y)
productSum <- function(x1,x2){
#find summation of (x1-x1_)(x2-x2_)
return(sum(x1*x2)-(sum(x1)*sum(x2))/length(x1))
}
findBk <- function(xk,xn,y){
num <- productSum(xn,xn)*productSum(xk,y) - productSum(xk,xn)*productSum(xn,y)
den <- productSum(xk,xk)*productSum(xn,xn) - productSum(xk,xn)^2
return(num/den)
}
b_1 <- findBk(x1,x2,y)
b_2 <- findBk(x2,x1,y)
b_0 <- y_ - b_1*x1_ - b_2*x2_
getPred<-function(x){
return (b_0+(b_1*x[1])+(b_2*x[2]))
}
x_test = data.frame("budgetNews"=c(150,300,450,600,750),"budgetTv"=c(3000,4000,5000,6000,7000))
predicted<-apply(x_test,1,getPred)
predicted
#using library function for mlr
model <- lm(totalUnits ~ budgetNews+budgetTv,data=data)
summary(model)
predictions_lib<-predict(model,x_test)
predictions_lib
#Comparison Table
library(grid)
library(gridExtra)
result = data.frame("budgetTv"=c(3000,4000,5000,6000,7000),"budgetNews"=c(150,300,450,600,750),"predictions"=predicted,"predictions_lib"=predictions_lib)
coeff_table <- data.frame("Non Predefined Function"=c(b_0,b_1,b_2),"Predefined Function"=summary(model)$coefficients[1:3])
rownames(coeff_table) <- c("Intercept", "budgetTv", "budgetNews")
grid.arrange(tableGrob(coeff_table),tableGrob(result))
table <- read.csv('ageloans.csv',header=TRUE,sep=',')
table
getPred<-function(x,k){
distance=vector()
age<-x[1]
loan<-x[2]
length(distance)=nrow(table)
for(i in 1:nrow(table))
{
distance[i]=sqrt(((age-table[i,1])^2)+((loan-table[i,2])^2))
}
#min(distance)
temp_table <- table
temp_table$dist <- distance
temp_table <- temp_table[order(temp_table$dist),]
n_classes <- temp_table[1:k,3]
count_table <- table(n_classes)
classes <- names(count_table)
return(classes[which.max(count_table)])
}
x_test <- data.frame("Age"=c(5,20,80),"Loan"=c(5,10000,300000))
pred1 <- apply(x_test,1,function(x) getPred(x,1))
pred2 <- apply(x_test,1,function(x) getPred(x,2))
pred3 <- apply(x_test,1,function(x) getPred(x,3))
#Library Function
library(class)
y_train <- table[,3]
x_train <- table[,1:2]
pred_lib1 <- knn(train = x_train,test=x_test,cl=y_train, k = 1)
pred_lib2 <- knn(train = x_train,test=x_test,cl=y_train, k = 2)
pred_lib3 <- knn(train = x_train,test=x_test,cl=y_train, k = 3)
#comparison table
library(grid)
library(gridExtra)
par(mfrow=c(2,3))
result1 <- data.frame("Age"=x_test[,1],"Loan"=x_test[,2],"Prediction"=pred1,"Prediction_Lib"=pred_lib1)
result2 <- data.frame("Age"=x_test[,1],"Loan"=x_test[,2],"Prediction"=pred2,"Prediction_Lib"=pred_lib2)
result3 <- data.frame("Age"=x_test[,1],"Loan"=x_test[,2],"Prediction"=pred3,"Prediction_Lib"=pred_lib3)
grid.arrange(tableGrob("k=1"),tableGrob(result1),tableGrob("k=2"),tableGrob(result2),tableGrob("k=3"),tableGrob(result3))
student <- read.table('student-marks.csv', header=TRUE, sep=',')
student
#Pie Chart and Bar Plot
for (row in 1:nrow(student)){
x <- as.numeric(student[row,-(1:3)])
labels <- colnames(student)[-(1:3)]
main_title <- paste (student[row, "Name"], "share of marks subject wise", sep=" ")
pie(x,labels, main=main_title)
main_title <- paste (student[row, "Name"], "marks subject wise", sep=" ")
barplot(x, names.arg = labels , main = main_title)
}
#Box plot and Histogram
subjects <- colnames(student)[-(1:3)]
boxplot(student[subjects],main="Student Marks Boxplot")
# for(s in subjects){
#   hist(student[[s]],main=s,ylab="Frequency",xlab="Marks")
# }
females <- student[student$Gender=="F",]
males <- student[student$Gender=="M",]
# females
# males
#Pie Chart and Bar Plot
subjects <- c("Physics","Maths","Chemistry","FOC","CAD")
gender_labels <- c("Male","Female")
for(s in subjects){
female_avg <- mean(females[[s]])
male_avg <- mean(males[[s]])
grades <- c(male_avg,female_avg)
pie(grades,gender_labels,main = paste(s,"Marks Share"))
barplot(grades,names.arg = gender_labels, main = s)
}
#Box Plot and Histogram
boxplot(females[subjects],main="Female Students' Performance Boxplot")
boxplot(males[subjects],main="Males Students' Performance Boxplot")
males[s]
mean(males[s])
mean(males[[s]])
males[[s]]
#LDA
# install.packages('ISLR')
library(ISLR) #credit card dataset
library(MASS)
dfr = Default
index = sample(x = 1:nrow(dfr), size = round(nrow(dfr) * 0.5))
train_dfr = dfr[index, ]
test_dfr = dfr[-index, ]
model = lda(default ~ student + balance + income, data = train_dfr)
summary(model)
pred = predict(model, test_dfr)
test_dfr$pred = pred$class
head(test_dfr)
table(test_dfr$pred, test_dfr$default)
head(dfr)
#QDA
library(ISLR)  #credit card - banking dataset
library(MASS)
dfr = Default
dfr$student = as.numeric(dfr$student)
dfr$student = as.factor(dfr$student)
index = sample(1:nrow(dfr), round(nrow(dfr) * 0.5))
train_dfr = dfr[index, ]
test_dfr = dfr[-index, ]
model = qda(default ~ student + balance + income, train_dfr)
summary(model)
pred = predict(model, test_dfr)
test_dfr$pred = pred$class
head(test_dfr)
table(test_dfr$pred, test_dfr$default)
student <- read.table('student-marks.csv', header=TRUE, sep=',')
student
#Pie Chart and Bar Plot
for (row in 1:nrow(student)){
x <- as.numeric(student[row,-(1:3)])
labels <- colnames(student)[-(1:3)]
main_title <- paste (student[row, "Name"], "share of marks subject wise", sep=" ")
pie(x,labels, main=main_title)
main_title <- paste (student[row, "Name"], "marks subject wise", sep=" ")
barplot(x, names.arg = labels , main = main_title)
}
#Box plot
subjects <- colnames(student)[-(1:3)]
boxplot(student[subjects],main="Student Marks Boxplot")
#Gender Split
females <- student[student$Gender=="F",]
males <- student[student$Gender=="M",]
# females
# males
#Pie Chart and Bar Plot
subjects <- c("Physics","Maths","Chemistry","FOC","CAD")
gender_labels <- c("Male","Female")
for(s in subjects){
female_avg <- mean(females[[s]])
male_avg <- mean(males[[s]])
grades <- c(male_avg,female_avg)
pie(grades,gender_labels,main = paste(s,"Marks Share"))
barplot(grades,names.arg = gender_labels, main = s)
}
#Box Plot
boxplot(females[subjects],main="Female Students' Performance Boxplot")
boxplot(males[subjects],main="Males Students' Performance Boxplot")
election <-  read.table('election.csv', header=TRUE, sep=',')
election
party <- unique(election["Party"])
party
vote_count <- replicate(nrow(party), 0)
counts <- data.frame(party, vote_count)
counts
for (row in (1:nrow(counts))){
val <- counts[row, "Party"]
voter_party_x <- election[election$Party == val, ]
counts [row, "vote_count"] <- nrow(voter_party_x)
}
counts
vote_x <- counts$vote_count
vote_labels <- counts$Party
pie (vote_x, vote_labels, main="vote share") #pie chart
barplot (vote_x, names.arg = vote_labels, main="vote share") #bar plot
boxplot (vote_x,main="Party Votes Boxplot")
hist (vote_x)
library(stringr)
table <- read.csv('dept.csv',header=TRUE,sep=',')
table
#Operations on dept.name
#Removing Redundant Whitespaces
table$dept.name <- sapply(table$dept.name,str_squish)
#Remove Numbers and Special Chars from dept.name
table$dept.name <- sapply(table$dept.name,function(x) str_replace_all(x,"[^A-Za-z\\s]",""))
#Convert Names to Lowercase
table$dept.name <- sapply(table$dept.name,tolower)
#Remove Redundant Names
table <- unique(table)
rownames(table) <- 1:nrow(table)
table
#Handle Characters in staff.count
table$staff.count <- sapply(table$staff.count, function(x) as.numeric(str_replace_all(x,"[^\\d]","")))
staff_mean <- round(mean(table$staff.count,na.rm=TRUE))
table$staff.count <- sapply(table$staff.count, function(x) if(is.na(x)) return(staff_mean) else return(x))
#Calculate outlier bounds
Q <- quantile(table$pub.count[which(!is.na(table$pub.count))], probs=c(.25, .75), na.rm = FALSE)
iqr <- IQR(table$pub.count[which(!is.na(table$pub.count))])
high <-  Q[2]+1.5*iqr
low<- Q[1]-1.5*iqr
pub_mean <- round(mean(table$pub.count, na.rm = TRUE))
#Function to replace outliers, NA and impossible values with mean
replace <- function(x){
if(x < low || x > high)
return(pub_mean)
else
return(x)
}
#Replace NA values and Outlier values with avg
table$pub.count <- sapply(table$pub.count,replace)
table
library(stringr)
table <- read.csv('Faculty.csv',header=TRUE,sep=',')
table
#Operations on faculty_name
#Removing Redundant Whitespaces
table$faculty_name <- sapply(table$faculty_name,str_squish)
#Remove Numbers and Special Chars from faculty_name
table$faculty_name <- sapply(table$faculty_name,function(x) str_replace_all(x,"[^A-Za-z\\s]",""))
#Convert Names to Lowercase
table$faculty_name <- sapply(table$faculty_name,tolower)
#Remove Redundant Names
table <- unique(table)
rownames(table) <- 1:nrow(table)
table
#Operations on Salary
#Handle Characters in salary
table$salary <- sapply(table$salary, function(x) as.numeric(str_replace_all(x,"[^\\d]","")))
salary_mean <- round(mean(table$salary,na.rm=TRUE))
#Calculate outlier bounds
Q <- quantile(table$salary[which(!is.na(table$salary))], probs=c(.25, .75), na.rm = FALSE)
iqr <- IQR(table$salary[which(!is.na(table$salary))])
high <-  Q[2]+1.5*iqr
low<- Q[1]-1.5*iqr
#Function to replace outliers, NA and impossible values with mean
replace <- function(x){
if(is.na(x) || x < low || x > high)
return(salary_mean)
else
return(x)
}
#Replace NA values and Outlier values with avg
table$salary <- sapply(table$salary,replace)
table
library(stringr)
table <- read.csv('students.csv',header=TRUE,sep=',')
table
#Operations on names
#Removing Redundant Whitespaces
table$names <- sapply(table$names,str_squish)
#Remove Numbers and Special Chars from names
table$names <- sapply(table$names,function(x) str_replace_all(x,"[^A-Za-z\\s]",""))
#Convert Names to Lowercase
table$names <- sapply(table$names,tolower)
#Remove Redundant Names
table <- unique(table)
rownames(table) <- 1:nrow(table)
table
#Operations on CGPA
percToCGPA <- function(x){
if(grepl("%",x,fixed = TRUE)==TRUE)
return(as.double(sub("%","",x))/10+0.75)
else
return(as.numeric(toString(x)))
}
#Convert Percentage to CGPA
table$cgpa <- sapply(table$cgpa,percToCGPA)
cgpa_mean <- round(mean(table$cgpa[which(table$cgpa>6 & table$cgpa<10)]),digits = 2)
#Calculate outlier bounds
Q <- quantile(table$cgpa[which(table$cgpa>6 & table$cgpa<10)], probs=c(.25, .75), na.rm = FALSE)
iqr <- IQR(table$cgpa[which(table$cgpa>6 & table$cgpa<10)])
high <-  Q[2]+1.5*iqr
low<- Q[1]-1.5*iqr
#Function to replace outliers, NA and impossible values with mean
replace <- function(x){
if(is.na(x) || x > 10 || x < 6 || x < low || x > high)
return(cgpa_mean)
else
return(x)
}
#Replace NA values and Outlier values with avg
table$cgpa <- sapply(table$cgpa,replace)
table
