sum((y_train-predict(model,train))^2)
sum((y_train - apply(x_train,1,getPred))^2)
sum((y_train-predict(model,train))^2)
sum((y_train - apply(x_train,1,getPred))^2)
getClass <- function(x){
if(x>=0.5)
return(1)
return(0)
}
pred <- sapply(apply(x_train,1,getPred),getClass)
predLib <- sapply(predict(model,x_train),getClass)
confusionMat <- function(x,y){
tp <- length(intersect(which(x==1),which(y==1)))
fp <- length(intersect(which(x==1),which(y==0)))
tn <- length(intersect(which(x==0),which(y==0)))
fn <- length(intersect(which(x==0),which(y==1)))
return(data.frame("Default"=c(tp,fp),"Non Default"=c(fn,tn),row.names = c("Default","Non Default")))
}
confusionMat(pred,y_train)
confusionMat(predLib,y_train)
confusionMat <- function(x,y){
tp <- length(intersect(which(x==1),which(y==1)))
fp <- length(intersect(which(x==1),which(y==0)))
tn <- length(intersect(which(x==0),which(y==0)))
fn <- length(intersect(which(x==0),which(y==1)))
return(data.frame("Default(Predicted)"=c(tp,fp),"Non Default(Predicted)"=c(fn,tn),row.names = c("Default(Actual)","Non Default(Actual)")))
}
confusionMat(pred,y_train)
confusionMat(predLib,y_train)
model <- glm(default ~ student + balance + income, data = train,family = binomial)
sum((y_train-predict(model,train))^2)
sum((y_train - apply(x_train,1,getPred))^2)
sum((y_train-predict(model,train))^2)
sum((y_train - apply(x_train,1,getPred))^2)
model <- glm(default ~ student + balance + income, data = train, family = binomial)
sum((y_train-predict(model,train))^2)
sum((y_train - apply(x_train,1,getPred))^2)
pred <- sapply(apply(x_train,1,getPred),getClass)
predLib <- sapply(predict(model,x_train),getClass)
confusionMat <- function(x,y){
tp <- length(intersect(which(x==1),which(y==1)))
fp <- length(intersect(which(x==1),which(y==0)))
tn <- length(intersect(which(x==0),which(y==0)))
fn <- length(intersect(which(x==0),which(y==1)))
return(data.frame("Default(Predicted)"=c(tp,fp),"Non Default(Predicted)"=c(fn,tn),row.names = c("Default(Actual)","Non Default(Actual)")))
}
confusionMat(pred,y_train)
confusionMat(predLib,y_train)
predict(model,x_train)
predict(model,x_train,type='response')
pred <- sapply(apply(x_train,1,getPred),getClass)
predLib <- sapply(predict(model,x_train,type='response'),getClass)
sum((y_train-predict(model,train,type='response'))^2)
sum((y_train - apply(x_train,1,getPred))^2)
sum((y_train-predict(model,x_train,type='response'))^2)
sum((y_train - apply(x_train,1,getPred))^2)
pred <- sapply(apply(x_train,1,getPred),getClass)
predLib <- sapply(predict(model,x_train,type='response'),getClass)
confusionMat(pred,y_train)
confusionMat(predLib,y_train)
sqrt(sum((y_train-predict(model,x_train,type='response'))^2))
sqrt(sum((y_train - apply(x_train,1,getPred))^2))
logisticReg <- function(X,Y,lr=1,threshold=0.1){
params <- rep(0,ncol(x_train)+1)
prev_loss <- 0.0
diff <- Inf
while(diff>threshold){
curr_loss <- 0.0
gradient <- rep(0,length(params))
diff <- 0
for(row in 1:nrow(X)){
x<-as.numeric(c(list(1),X[row,]))
pred <- as.double(1/as.double(1+exp(-(x%*%params))))
loss <- Y[row] - pred
curr_loss <- curr_loss + (loss^2)
for(p in 1:length(params)){
params[p] <- params[p] + lr*x[p]*loss
}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
logisticReg <- function(X,Y,lr=1,threshold=0.1){
params <- rep(0,ncol(x_train)+1)
prev_loss <- 0.0
diff <- Inf
while(TRUE){
curr_loss <- 0.0
gradient <- rep(0,length(params))
diff <- 0
stp <- FALSE
for(row in 1:nrow(X)){
x<-as.numeric(c(list(1),X[row,]))
pred <- as.double(1/as.double(1+exp(-(x%*%params))))
loss <- Y[row] - pred
curr_loss <- curr_loss + (loss^2)
for(p in 1:length(params)){
params[p] <- params[p] + lr*x[p]*loss
}
if(sqrt(sum((lr*loss*x)))<threshold){
stp = TRUE
break
}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
if(stp)
break
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
logisticReg <- function(X,Y,lr=1,threshold=0.1){
params <- rep(0,ncol(x_train)+1)
prev_loss <- 0.0
diff <- Inf
while(TRUE){
curr_loss <- 0.0
gradient <- rep(0,length(params))
diff <- 0
stp <- FALSE
for(row in 1:nrow(X)){
x<-as.numeric(c(list(1),X[row,]))
pred <- as.double(1/as.double(1+exp(-(x%*%params))))
loss <- Y[row] - pred
curr_loss <- curr_loss + (loss^2)
for(p in 1:length(params)){
params[p] <- params[p] + lr*x[p]*loss
}
if(sqrt(sum((lr*loss*x)))<threshold){
stp = TRUE
break
}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
if(stp)
break
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
logisticReg <- function(X,Y,lr=1,threshold=0.1){
params <- rep(0,ncol(x_train)+1)
prev_loss <- 0.0
diff <- Inf
while(TRUE){
curr_loss <- 0.0
gradient <- rep(0,length(params))
stp <- FALSE
for(row in 1:nrow(X)){
diff <- 0
x<-as.numeric(c(list(1),X[row,]))
pred <- as.double(1/as.double(1+exp(-(x%*%params))))
loss <- Y[row] - pred
curr_loss <- curr_loss + (loss^2)
for(p in 1:length(params)){
params[p] <- params[p] + lr*x[p]*loss
diff <- diff + (lr*x[p]*loss)^2
}
if(sqrt(diff)<threshold){
stp = TRUE
break
}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
# diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
if(stp)
break
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
logisticReg <- function(X,Y,lr=1,threshold=0.001){
params <- rep(0,ncol(x_train)+1)
prev_loss <- 0.0
diff <- Inf
while(TRUE){
curr_loss <- 0.0
gradient <- rep(0,length(params))
stp <- FALSE
for(row in 1:nrow(X)){
diff <- 0
x<-as.numeric(c(list(1),X[row,]))
pred <- as.double(1/as.double(1+exp(-(x%*%params))))
loss <- Y[row] - pred
curr_loss <- curr_loss + (loss^2)
for(p in 1:length(params)){
params[p] <- params[p] + lr*x[p]*loss
diff <- diff + (lr*x[p]*loss)^2
}
if(sqrt(diff)<threshold){
stp = TRUE
break
}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
# diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
if(stp)
break
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
logisticReg <- function(X,Y,lr=1,threshold=0.00001){
params <- rep(0,ncol(x_train)+1)
prev_loss <- 0.0
diff <- Inf
while(TRUE){
curr_loss <- 0.0
gradient <- rep(0,length(params))
stp <- FALSE
for(row in 1:nrow(X)){
diff <- 0
x<-as.numeric(c(list(1),X[row,]))
pred <- as.double(1/as.double(1+exp(-(x%*%params))))
loss <- Y[row] - pred
curr_loss <- curr_loss + (loss^2)
for(p in 1:length(params)){
params[p] <- params[p] + lr*x[p]*loss
diff <- diff + (lr*x[p]*loss)^2
}
if(sqrt(diff)<threshold){
stp = TRUE
break
}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
# diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
if(stp)
break
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
sqrt(sum((y_train-predict(model,x_train,type='response'))^2))
sqrt(sum((y_train - apply(x_train,1,getPred))^2))
logisticReg <- function(X,Y,lr=1,threshold=0.1){
params <- rep(0,ncol(x_train)+1)
prev_loss <- 0.0
diff <- Inf
while(diff>threshold){
curr_loss <- 0.0
gradient <- rep(0,length(params))
diff <- 0
for(row in 1:nrow(X)){
x<-as.numeric(c(list(1),X[row,]))
pred <- as.double(1/as.double(1+exp(-(x%*%params))))
loss <- Y[row] - pred
curr_loss <- curr_loss + (loss^2)
for(p in 1:length(params)){
params[p] <- params[p] + lr*x[p]*loss
}
# diff <- sqrt(diff)
# print(diff)
}
# for(p in 1:length(params))
#   params[p] <- params[p] + (lr*gradient[p])/nrow(X)
curr_loss <- sqrt(curr_loss)
diff <- abs(curr_loss-prev_loss)
prev_loss <- curr_loss
print(curr_loss)
}
# print(curr_loss)
return(params)
}
params <- logisticReg(x_train,y_train)
data <- read.csv('salesmlr.csv')
x1 <- data$budgetNews
x2 <- data$budgetTv
y <- data$totalUnits
productSum <- function(x1,x2){
#find summation of (x1-x1_)(x2-x2_)
return(sum(x1*x2)-(sum(x1)*sum(x2))/length(x1))
}
findBk <- function(xk,xn,y){
num <- productSum(xn,xn)*productSum(xk,y) - productSum(xk,xn)*productSum(xn,y)
den <- productSum(xk,xk)*productSum(xn,xn) - productSum(xk,xn)^2
return(num/den)
}
b_1 <- findBk(x1,x2,y)
b_2 <- findBk(x2,x1,y)
b_0 <- y_ - b_1*x1_ - b_2*x2_
getPred<-function(x){
return (b_0+(b_1*x[1])+(b_2*x[2]))
}
x_test = data.frame("budgetNews"=c(150,300,450,600,750),"budgetTv"=c(3000,4000,5000,6000,7000))
predicted<-apply(x_test,1,getPred)
predicted
b_0 <- y_ - b_1*x1_ - b_2*x2_
x1_ <- sum(x1)/length(x1)
x2_ <- sum(x2)/length(x2)
y_ <- sum(y)/length(y)
b_1 <- findBk(x1,x2,y)
b_2 <- findBk(x2,x1,y)
b_0 <- y_ - b_1*x1_ - b_2*x2_
getPred<-function(x){
return (b_0+(b_1*x[1])+(b_2*x[2]))
}
x_test = data.frame("budgetNews"=c(150,300,450,600,750),"budgetTv"=c(3000,4000,5000,6000,7000))
predicted<-apply(x_test,1,getPred)
predicted
#using library function for mlr
model <- lm(totalUnits ~ budgetNews+budgetTv,data=data)
summary(model)
predictions_lib<-predict(model,x_test)
predictions_lib
#Comparison Table
library(grid)
library(gridExtra)
result = data.frame("budgetTv"=c(3000,4000,5000,6000,7000),"budgetNews"=c(150,300,450,600,750),"predictions"=predicted,"predictions_lib"=predictions_lib)
grid.table(result)
coeff_table <- data.frame("Non Predefined Function"=c(b_0,b_1,b_2),"Predefined Function"=summary(model)$coefficients[1:3])
rownames(coeff_table) <- c("Intercept", "budgetTv", "budgetNews")
grid.arrange(tableGrob(coeff_table),tableGrob(result))
data <- read.csv('salesmlr.csv')
x1 <- data$budgetNews
x2 <- data$budgetTv
y <- data$totalUnits
x1_ <- sum(x1)/length(x1)
x2_ <- sum(x2)/length(x2)
y_ <- sum(y)/length(y)
productSum <- function(x1,x2){
#find summation of (x1-x1_)(x2-x2_)
return(sum(x1*x2)-(sum(x1)*sum(x2))/length(x1))
}
findBk <- function(xk,xn,y){
num <- productSum(xn,xn)*productSum(xk,y) - productSum(xk,xn)*productSum(xn,y)
den <- productSum(xk,xk)*productSum(xn,xn) - productSum(xk,xn)^2
return(num/den)
}
b_1 <- findBk(x1,x2,y)
b_2 <- findBk(x2,x1,y)
b_0 <- y_ - b_1*x1_ - b_2*x2_
getPred<-function(x){
return (b_0+(b_1*x[1])+(b_2*x[2]))
}
x_test = data.frame("budgetNews"=c(150,300,450,600,750),"budgetTv"=c(3000,4000,5000,6000,7000))
predicted<-apply(x_test,1,getPred)
predicted
#using library function for mlr
model <- lm(totalUnits ~ budgetNews+budgetTv,data=data)
summary(model)
predictions_lib<-predict(model,x_test)
predictions_lib
#Comparison Table
library(grid)
library(gridExtra)
result = data.frame("budgetTv"=c(3000,4000,5000,6000,7000),"budgetNews"=c(150,300,450,600,750),"predictions"=predicted,"predictions_lib"=predictions_lib)
grid.table(result)
coeff_table <- data.frame("Non Predefined Function"=c(b_0,b_1,b_2),"Predefined Function"=summary(model)$coefficients[1:3])
rownames(coeff_table) <- c("Intercept", "budgetTv", "budgetNews")
grid.arrange(tableGrob(coeff_table),tableGrob(result))
data <- read.csv('salesmlr.csv')
x1 <- data$budgetNews
x2 <- data$budgetTv
y <- data$totalUnits
x1_ <- sum(x1)/length(x1)
x2_ <- sum(x2)/length(x2)
y_ <- sum(y)/length(y)
productSum <- function(x1,x2){
#find summation of (x1-x1_)(x2-x2_)
return(sum(x1*x2)-(sum(x1)*sum(x2))/length(x1))
}
findBk <- function(xk,xn,y){
num <- productSum(xn,xn)*productSum(xk,y) - productSum(xk,xn)*productSum(xn,y)
den <- productSum(xk,xk)*productSum(xn,xn) - productSum(xk,xn)^2
return(num/den)
}
b_1 <- findBk(x1,x2,y)
b_2 <- findBk(x2,x1,y)
b_0 <- y_ - b_1*x1_ - b_2*x2_
getPred<-function(x){
return (b_0+(b_1*x[1])+(b_2*x[2]))
}
x_test = data.frame("budgetNews"=c(150,300,450,600,750),"budgetTv"=c(3000,4000,5000,6000,7000))
predicted<-apply(x_test,1,getPred)
predicted
#using library function for mlr
model <- lm(totalUnits ~ budgetNews+budgetTv,data=data)
summary(model)
predictions_lib<-predict(model,x_test)
predictions_lib
#Comparison Table
library(grid)
library(gridExtra)
result = data.frame("budgetTv"=c(3000,4000,5000,6000,7000),"budgetNews"=c(150,300,450,600,750),"predictions"=predicted,"predictions_lib"=predictions_lib)
coeff_table <- data.frame("Non Predefined Function"=c(b_0,b_1,b_2),"Predefined Function"=summary(model)$coefficients[1:3])
rownames(coeff_table) <- c("Intercept", "budgetTv", "budgetNews")
grid.arrange(tableGrob(coeff_table),tableGrob(result))
table <- read.csv('ageloans.csv',header=TRUE,sep=',')
table
getPred<-function(x,k){
distance=vector()
age<-x[1]
loan<-x[2]
length(distance)=nrow(table)
for(i in 1:nrow(table))
{
distance[i]=sqrt(((age-table[i,1])^2)+((loan-table[i,2])^2))
}
#min(distance)
temp_table <- table
temp_table$dist <- distance
temp_table <- temp_table[order(temp_table$dist),]
n_classes <- temp_table[1:k,3]
count_table <- table(n_classes)
classes <- names(count_table)
return(classes[which.max(count_table)])
}
x_test <- data.frame("Age"=c(5,20,80),"Loan"=c(5,10000,300000))
pred1 <- apply(x_test,1,function(x) getPred(x,1))
pred2 <- apply(x_test,1,function(x) getPred(x,2))
pred3 <- apply(x_test,1,function(x) getPred(x,3))
#Library Function
library(class)
y_train <- table[,3]
x_train <- table[,1:2]
pred_lib1 <- knn(train = x_train,test=x_test,cl=y_train, k = 1)
pred_lib2 <- knn(train = x_train,test=x_test,cl=y_train, k = 2)
pred_lib3 <- knn(train = x_train,test=x_test,cl=y_train, k = 3)
#comparison table
library(grid)
library(gridExtra)
par(mfrow=c(2,3))
result1 <- data.frame("Age"=x_test[,1],"Loan"=x_test[,2],"Prediction"=pred1,"Prediction_Lib"=pred_lib1)
result2 <- data.frame("Age"=x_test[,1],"Loan"=x_test[,2],"Prediction"=pred2,"Prediction_Lib"=pred_lib2)
result3 <- data.frame("Age"=x_test[,1],"Loan"=x_test[,2],"Prediction"=pred3,"Prediction_Lib"=pred_lib3)
grid.arrange(tableGrob("k=1"),tableGrob(result1),tableGrob("k=2"),tableGrob(result2),tableGrob("k=3"),tableGrob(result3))
student <- read.table('student-marks.csv', header=TRUE, sep=',')
student
#Pie Chart and Bar Plot
for (row in 1:nrow(student)){
x <- as.numeric(student[row,-(1:3)])
labels <- colnames(student)[-(1:3)]
main_title <- paste (student[row, "Name"], "share of marks subject wise", sep=" ")
pie(x,labels, main=main_title)
main_title <- paste (student[row, "Name"], "marks subject wise", sep=" ")
barplot(x, names.arg = labels , main = main_title)
}
#Box plot and Histogram
subjects <- colnames(student)[-(1:3)]
boxplot(student[subjects],main="Student Marks Boxplot")
# for(s in subjects){
#   hist(student[[s]],main=s,ylab="Frequency",xlab="Marks")
# }
females <- student[student$Gender=="F",]
males <- student[student$Gender=="M",]
# females
# males
#Pie Chart and Bar Plot
subjects <- c("Physics","Maths","Chemistry","FOC","CAD")
gender_labels <- c("Male","Female")
for(s in subjects){
female_avg <- mean(females[[s]])
male_avg <- mean(males[[s]])
grades <- c(male_avg,female_avg)
pie(grades,gender_labels,main = paste(s,"Marks Share"))
barplot(grades,names.arg = gender_labels, main = s)
}
#Box Plot and Histogram
boxplot(females[subjects],main="Female Students' Performance Boxplot")
boxplot(males[subjects],main="Males Students' Performance Boxplot")
males[s]
mean(males[s])
mean(males[[s]])
males[[s]]
